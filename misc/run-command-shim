#!/usr/bin/env bash

set -e -o pipefail
readonly SCRIPT_DIR=$(dirname "$0")
readonly LOG_DIR="/var/log/azure/run-command-handler"
readonly LOG_FILE=handler.log
readonly ARCHITECTURE=$( [[ "$(uname -p)" == "unknown" ]] && echo "$(uname -m)" || echo "$(uname -p)" ) #ternary operator
HANDLER_BIN="run-command-handler"
if [ $ARCHITECTURE == "arm64" ] || [ $ARCHITECTURE == "aarch64" ]; then
     HANDLER_BIN="run-command-handler-arm64";
fi

# in multiconfig case $ConfigExtensionName and $ConfigSequenceNumber should be set by the agent
readonly EXTENSION_NAME=$ConfigExtensionName
readonly SEQNO=$ConfigSequenceNumber
readonly LOCKFILE="./run-command-handler.lock"
echo "ConfigExtensionName: $EXTENSION_NAME"
echo "ConfigSequenceNumber: $SEQNO"
echo Architecture: $ARCHITECTURE
echo Binary: $HANDLER_BIN
LOCK_ACQUIRED=0

get_lock() {
    set +e # disable exit on non-zero return code
    local retry_attempts=0

    # Create lock file if it does not exist
    if [ ! -f "$LOCKFILE" ]; then
        touch "$LOCKFILE"
        echo "Lock file '$LOCKFILE' has been created."
    fi
 
    while (( retry_attempts < 10 )); do
        # Acquire the exclusive (-x) and non-blocking (-n) lock on the lock file (side note: flock is part of util-linux package and is available by default on most Linux distros)
        if ! flock -x -n $LOCKFILE; then
            echo "Lock already held by another process. Retrying..."
            ((++retry_attempts))
            echo "sleeping for 3 seconds before retry, attempt ${retry_attempts} of 10"
            sleep 3
            continue
        else
            echo "Lock acquired on file '$LOCKFILE'"
            LOCK_ACQUIRED=1
            break
        fi
    done
    # Do not return error if lock not acquired even after retries expire, make a best effort attempt to start run-command-handler
    if [ "$LOCK_ACQUIRED" -eq 0 ]; then
        echo "Lock was not acquired on '$LOCKFILE' after retries. Making best-effort attempt to start run-command-handler..."
    fi
    set -e
    return 0
}

if [ "$#" -ne 1 ]; then
    echo "Incorrect usage."
    echo "Usage: $0 <command>"
    exit 1
fi

# Redirect logs of the handler process
mkdir -p "$LOG_DIR"
exec &> >(tee -ia "$LOG_DIR/$LOG_FILE")

# Start handling the process in the background
bin="$(readlink -f "$SCRIPT_DIR/$HANDLER_BIN")"
cmd="$1"

if [[ "$cmd" == "enable" ]]; then
    # for 'enable' command, double fork
    # to detach from the handler process tree to avoid getting terminated 
    # after the 15-minute extension enabling timeout.
    get_lock
    set -x
    # & will execute the binary on the backgraound and will not block current shell execution
    nohup "$bin" "$cmd" &
else
    # execute the handler process as a child process
    get_lock
    set -x
    "$bin" "$cmd"
fi
# Exiting the script releases the lock on $LOCKFILE by closing the file descriptor associated with the lock.
