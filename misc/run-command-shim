#!/usr/bin/env bash

set -e -o pipefail
readonly SCRIPT_DIR=$(dirname "$0")
readonly LOG_DIR="/var/log/azure/run-command-handler"
readonly LOG_FILE=handler.log
readonly ARCHITECTURE=$( [[ "$(uname -p)" == "unknown" ]] && echo "$(uname -m)" || echo "$(uname -p)" ) #ternary operator
HANDLER_BIN="run-command-handler"
if [ $ARCHITECTURE == "arm64" ] || [ $ARCHITECTURE == "aarch64" ]; then
     HANDLER_BIN="run-command-handler-arm64";
fi

# in multiconfig case $ConfigExtensionName and $ConfigSequenceNumber should be set by the agent
readonly EXTENSION_NAME=$ConfigExtensionName
readonly SEQNO=$ConfigSequenceNumber
readonly LOCKFILE="./run-command-handler.lock"
echo "ConfigExtensionName: $EXTENSION_NAME"
echo "ConfigSequenceNumber: $SEQNO"
echo Architecture: $ARCHITECTURE
echo Binary: $HANDLER_BIN
LOCK_ACQUIRED=0

if [ "$#" -ne 1 ]; then
    echo "Incorrect usage."
    echo "Usage: $0 <command>"
    exit 1
fi

# Redirect logs of the handler process
mkdir -p "$LOG_DIR"
exec &> >(tee -ia "$LOG_DIR/$LOG_FILE")

# Start handling the process in the background
bin="$(readlink -f "$SCRIPT_DIR/$HANDLER_BIN")"
cmd="$1"

# For commands other than 'enable', execute the handler process as a child process
commandToExecute="$bin $cmd"

if [[ "$cmd" == "enable" ]]; then
    # for 'enable' command, double fork
    # to detach from the handler process tree to avoid getting terminated 
    # after the 15-minute extension enabling timeout.
    # & will execute the binary on the background and will not block current shell execution
    commandToExecute="nohup $bin $cmd &"
fi

### Retry logic to acquire lock and execute the command
set +e # disable exit on non-zero return code
retry_attempts=0

# Create lock file if it does not exist
if [ ! -f "$LOCKFILE" ]; then
    touch "$LOCKFILE"
    echo "Lock file $LOCKFILE has been created."
fi

set -x
while (( retry_attempts < 10 )); do
    # Acquire the exclusive (-x) and non-blocking (-n) lock on the lock file and execute $commandToExecute(side note: flock is part of util-linux package and is available by default on most Linux distros)
    flock -x -n "$LOCKFILE" -c "$commandToExecute"
    flock_status=$? # Capture the exit status of the flock command

    if [ $flock_status -eq 1 ]; then
        echo "Lock already held by another process. Retrying..."
        ((++retry_attempts))
        echo "sleeping for 3 seconds before retry, attempt ${retry_attempts} of 10"
        sleep 3
        continue
    elif [ $flock_status -eq 0 ]; then
        LOCK_ACQUIRED=1
        echo "Lock acquired on file $LOCKFILE and executed command $commandToExecute successfully. Exiting."
        break
    else
        echo "Failed to execute command $commandToExecute with flock on file $LOCKFILE. Exiting with exit code $flock_status"         
        break
    fi
done
set +x
### End of retry logic

# Do not return error if lock not acquired even after retries expire, make a best effort attempt to start run-command-handler
if [ "$LOCK_ACQUIRED" -eq 0 ]; then
    echo "Lock was not acquired on $LOCKFILE after retries. Making best-effort attempt to start run-command-handler..."
    set -x
    $commandToExecute
    set +x
fi
set -e

# Exiting the script releases the lock on $LOCKFILE by closing the file descriptor associated with the lock.
